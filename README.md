# Cloud Native Component Framework

Cloud Native Component Framework (CNCF) is a Scala-based runtime framework
for executing **components automatically generated by Cozy Modeling Language**,
with first-class support for **event-centered, asynchronous execution**
in cloud-native environments.

The framework provides a **stable and operable runtime foundation**
for model-driven systems, balancing reliability, flexibility, and
operational realism without enforcing excessive architectural constraints
such as full Event Sourcing.

---

## Scope and Responsibility

This project provides **foundational infrastructure** for component-based systems
used across the SimpleModeling ecosystem.

This is **NOT** an application framework.

Its responsibility is to define and standardize:

- component boundaries
- execution / runtime context handling
- configuration resolution
- operational semantics shared by multiple systems

Semantic Integration Engine (SIE) is the first real consumer,
but it is **NOT** the owner of these mechanisms.

## Core Dependencies

CNCF depends on goldenport core for the following abstractions:

- `EnvironmentContext`
- `ExecutionContext` (core abstraction; CNCF provides a runtime-bound instance)
- `CanonicalId`

These abstractions are **core-owned**.
CNCF must not reinterpret or extend their semantics.

CNCF responsibilities are limited to:

- detecting environment facts at bootstrap (currently via `EnvironmentContext.Local.detect`)
- explicitly constructing core contexts
- injecting contexts into runtime flows
- using `CanonicalId` as a correlation identifier only

CanonicalId generation is not implemented in CNCF.

## Purpose

The primary purpose of this framework is to answer the following question:

> How can we reliably execute model-generated domain components
> in a cloud-native, asynchronous, and operable way?

Cloud Native Component Framework provides:

- A runtime contract for Cozy-generated components
- Event-centered asynchronous execution between components
- Job-managed execution for observability and recovery
- Clear separation between domain logic and infrastructure
- Compatibility with AI-assisted and knowledge-driven workflows
- Design and rules index: `docs/rules/README.md`

---

## Configuration Resolution (Foundational Layer)

The first concrete and highest-priority subsystem in this framework is
**Local / Runtime Configuration Resolution**.

This layer is responsible for:

- discovering configuration sources
- resolving precedence
- merging configurations deterministically
- returning a single evaluated configuration object

This mechanism is designed to be:

- reusable by any component
- independent of SIE-specific semantics
- safe for both local and cloud execution

Important principle:

```
config resolution != config semantics
```

## Package Overview

The main packages under `org.simplemodeling.componentframework` are organized as follows:

- `datatype`  
  Basic domain data types shared across components

- `entity`  
  Entity abstractions and storage-related contracts

- `service`  
  Core execution model:
  Command, OperationCall, Engine, Service

- `event`  
  Event abstraction and listener contracts

- `unitofwork`  
  Experimental execution and transaction composition models

---


## Core Architecture

### Component Interaction Contract (Conceptual)

In addition to execution-time abstractions such as Component and OperationCall,
this framework recognizes a *conceptual interaction layer* that defines
what kinds of interactions a component is allowed to accept.

This layer is referred to as the **Component Interaction Contract**.

The Component Interaction Contract is not yet a stabilized API in CNCF,
but it provides an important design perspective discovered through
real-world usage (notably via the Semantic Integration Engine).

Conceptually, the contract is decomposed into two symmetric parts:

- **Component Operation Language**  
  Defines synchronous interactions (commands, queries, requestâ€“response operations)
  that are transformed into OperationCall instances before execution.

- **Component Reception Language**  
  Defines asynchronous interactions (event reception) that admit external signals
  into the component and trigger event-driven execution paths.

The stable execution boundary of the framework remains the **OperationCall**.
The Interaction Contract describes how operations and events are *admitted*
into the system before execution is coordinated by the runtime.

This conceptual layer is documented in more detail in `docs/design/component-model.md`
and is expected to inform future refinement of the Component and OperationCall models.


### Component

A **Component** represents a deployable runtime unit.

Responsibilities:

- Lifecycle management
- Configuration binding
- Integration with infrastructure
- Execution orchestration

Components do **not** embed domain logic directly.

---

### Componentlet

A **Componentlet** encapsulates **pure domain logic**, typically generated
by Cozy from domain models.

Characteristics:

- Deterministic and side-effect free (or explicitly controlled)
- Independent of infrastructure
- Expressed as functions or algebraic interfaces
- Executed only through OperationCall

Generated Componentlets are treated as **replaceable artifacts**.

### OperationCall

Responsibilities:

- Bind an explicit ExecutionContext
- Declare accessed resources (authorization intent)
- Apply cross-cutting concerns (observability, authorization hooks)
- Handle error mapping (Consequence / Conclusion)
- Mediate synchronous and asynchronous execution

OperationCall is a fully-bound executable unit.
It does not rely on implicit ExecutionContext.

---

### Execution Context

ExecutionContext represents explicit runtime information bound to an OperationCall.

Typical contents:

- Security context (principal, capabilities, security level)
- Time / Clock
- Locale
- Configuration snapshot
- Tracing identifiers

ExecutionContext is:

- Constructed outside Engine
- Bound to OperationCall at creation time
- Not implicit
- Not visible in domain function signatures

ExecutionContext is a CNCF runtime contract for CNCF consumers.
Consumers (including SIE) should rely on CNCF documentation only;
knowledge of core abstractions is not required.

Authoritative execution semantics are defined in:
- docs/design/execution-model.md

---

## Event-Centered Architecture

True cloud-native execution requires robust support for asynchronous
interaction between components.

This framework adopts **Event-Centered Architecture**, positioned between
Event-Driven Architecture and Event Sourcing.

```
Event Sourcing > Event-Centered Architecture > Event-Driven Architecture
```

Event-Centered Architecture treats events as **execution artifacts**
without requiring full event journaling or state reconstruction.

## Asynchronous Execution Model

Component-to-component asynchronous execution is supported through
**two complementary interaction models**:

- **Command**
- **Event**

Both are first-class execution mechanisms and are, by default,
executed under **Job management**.

---

### Command (Tight Coupling)

A **Command** represents an explicit execution request.

Characteristics:

- Intent-oriented (do something)
- Targets a specific component or capability
- Strong expectation of execution and outcome
- Asynchronous by default
- Managed under Job control

Commands imply **intentional coordination** between components.

Although conceptually tight, Commands may be dispatched via Pub/Sub
transport when necessary, without changing their semantic meaning.

---

### Event (Loose Coupling)

An **Event** represents a fact that has occurred.

Characteristics:

- Fact-oriented
- Zero or more consumers
- No assumption about response or completion
- Triggers reactive behavior
- Managed under Job control by default

Events emphasize **decoupling and flexibility** over determinism.

---

### Command vs Event

```
Command: Tight intent, controlled execution
Event:   Loose signal, open reaction
```

Semantic intent is kept independent from transport mechanisms.

## Job-Managed Execution

By default, **both Command and Event executions are managed as Jobs**.

Job management provides:

- Execution lifecycle tracking
- Explicit success / failure recording
- Retry and compensation control
- Historical execution records
- Operational visibility

This enables reliable asynchronous execution without enforcing
full Event Sourcing.

---

## Failure Responsibility and Recovery

Failures during Command or Event execution are **recorded by Job management**.

Each Job is associated with OpenTelemetry-compatible identifiers:

- job id
- task id
- trace id
- span id

Recovery paths include:

- Application-level detection and automated recovery
- Operator-driven inspection and manual recovery
- Post-mortem analysis using logs, traces, and metrics

The framework records failures but does not mandate recovery policies.

---

## Job Visualization and Management API

The framework provides job management capabilities equivalent to
traditional enterprise job control systems, including:

- Job state inspection (pending / running / completed / failed)
- Execution result and error details
- Retry, cancel, suspend, and resume operations
- Historical job search and filtering

These APIs support both programmatic control and operational tooling.

## Modeling Command and Event in Cozy

In Cozy Modeling Language, **Command and Event are modeled as first-class
elements**, alongside Entity and Value.

This allows:

- Explicit modeling of Commands and Events
- Code generation aligned with runtime semantics
- Clear separation between intent (Command) and fact (Event)
- Direct mapping between models and execution behavior

---

## Synchronous Operations and Job Management

Synchronous operations are supported and may optionally be executed
under Job management.

Execution modes:

- Default synchronous execution
  - Immediate execution
  - Observability via OpenTelemetry
- Job-managed synchronous execution
  - Unified tracking with asynchronous operations

Mission-critical or core transactional updates may enable Job management
by default, while typical application operations remain lightweight.

---

## Cloud-Native and AI Readiness

The framework is designed to be:

- Container-friendly
- Deployable locally, in demo environments, and in production
- Observable via standard tooling (OpenTelemetry)
- Introspectable and controllable by AI agents

This makes it suitable as a runtime foundation for
AI-assisted, knowledge-driven, and model-driven systems.

---

## Related Projects

- **Cozy Modeling Language** â€” model-driven code generation
- **Semantic Integration Engine (SIE)** â€” knowledge retrieval and reasoning
- **SmartDox** â€” literate model-driven documentation

Together, these projects form the SimpleModeling ecosystem.

---

## Relationship to SIE

Semantic Integration Engine (SIE) consumes this framework
but must not own or specialize its internal mechanisms.

SIE is expected to:

- call the frameworkâ€™s public APIs
- receive resolved runtime artifacts (e.g. configuration)
- interpret them via thin adapter layers

SIE must NOT:

- re-implement discovery or resolution logic
- bypass merge or precedence rules
- embed component-framework internals

SIE is a consumer, not a special case.

---

## ðŸ§ª Test Policy

This project adopts a **layered testing policy**.

Tests are not primarily used to verify detailed behavior.
Instead, they are used to capture intent, preserve architectural freedom,
and validate execution paths at appropriate layers.

### Unit Tests (`src/test`)

- Treated as *working specifications*
- Focus on public APIs and semantic intent
- Written using ScalaTest `AnyWordSpec`
- Executed on every CI cycle

### Integration Tests (`src/it/integration`)

- Validate execution-level composition
- Verify protocol boundaries, wiring, and adapters
- Executed selectively

### Scenario Tests (`src/it/scenario`)

- Represent **use case scenarios**
- Describe end-to-end flows
- May use BDD style (Given / When / Then)

BDD is treated as a **description technique**, not a directory
or architectural layer.

For the normative test specification, see:
`docs/spec/test-policy.md`

----

## License

Cloud Native Component Framework is released under:

- **Apache License 2.0** â€” software
- **CC-BY-SA 4.0** â€” documentation

Â© 2025 ASAMI, Tomoharu / SimpleModeling.org  
Maintained by Asami Office Inc. ((æœ‰)æµ…æµ·æ™ºæ™´äº‹å‹™æ‰€)

----

## Contributing

Contributions are welcome!

Please review:

- `CONTRIBUTING.md`
- `CLA.md`

Submitting a Pull Request implies agreement
to the Contributor License Agreement.

----

## Contact

Cloud Native Component Framework is developed and maintained by:

**ASAMI, Tomoharu**  
https://www.simplemodeling.org  
info@simplemodeling.org
